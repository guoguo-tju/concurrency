	


并发:
	同时拥有两个或者多个线程,如果程序在单核处理器上运行,多个线程交替地换入或者换出内存,这些线程是同时"存在"的,每个线程都处于执行过程中的某个状态,如果运行多核处理器上,此时,程序中每个线程都将分配到一个处理核上,因此,可以同时运行.

CPU多级缓存:
	*为什么需要CPU缓存呢?
	因为CPU的频率太快了,快到主存跟不上,这样在处理器时钟周期内,CPU常常需要等待主存,浪费资源.所以cache的出现,是为了缓解CPU和内存之间速度的不匹配问题(结构:CPU-->cache-->memory)	
	*保证缓存的一致性(MESI协议)
		参考博客: https://blog.csdn.net/muxiqingyang/article/details/6615199
	*乱序执行优化
	处理器为提高运算速度而做出的违背代码原有顺序的优化(重排序).单核的环境下处理结果与预期相同,但多核情况下,多个核来执行指令,每个核都可能被乱序,使得结果偏离预期.
	*Java内存模型(Java Memory Model --JMM)
		`它规定了一个线程如何和何时可以看到其他线程修改过的共享变量的值，以及在必须时如何同步地访问共享变量
		`堆Heap:运行时数据区，有垃圾回收，堆的优势可以动态分配内存大小，生存期也不必事先告诉编译器，因为他是在运行时动态分配内存。缺点是由于运行时动态分配内存，所以存取速度慢一些。
		`栈Stack:优势存取速度快，速度仅次于计算机的寄存器。栈的数据是可以共享的，但是缺点是存在栈中数据的大小与生存期必须是确定的。主要存放基本类型变量，对象据点。要求调用栈和本地变量存放在线程栈上。
		`静态类型变量跟随类的定义存放在堆上。存放在堆上的对象可以被所持有对这个对象引用的线程访问。
		`如果两个线程同时调用了同一个对象的同一个方法，他们都会访问这个对象的成员变量。但是这两个线程都拥有的是该对象的成员变量（局部变量）的私有拷贝。—[线程封闭中的堆栈封闭]
	*计算机硬件架构:
		`CPU Registers(寄存器):是CPU内存的基础，CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器速度远大于主存。
		`CPU Cache Memory(高速缓存):由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存，来作为内存与处理器之间的缓冲。将运算时所使用到的数据复制到缓存中,让运算能快速的进行。当运算结束后，再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。
		`RAM-Main Memory(主存/内存):当一个CPU需要读取主存的时候，他会将主存中的部分读取到CPU缓存中，甚至他可能将缓存中的部分内容读到他的内部寄存器里面，然后在寄存器中执行操作。当`CPU需要将结果回写到主存的时候，他会将内部寄存器中的值刷新到缓存中，然后在某个时间点从缓存中刷回主存。
	*JMM与硬件架构的关系
		`Java内存模型抽象结构：每个线程都有一个私有的本地内存，本地内存他是java内存模型的一个抽象的概念。它并不是真实存在的，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器的优化。本地内存中它存储了该线程以读或写共享变量拷贝的一个副本。
		`从更低的层次来说，主内存就是硬件的内存，是为了获取更高的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中，java内存模型中的线程的工作内存是CPU的寄存器和高速缓存的一个抽象的描述。而JVM的静态内存存储模型它只是对内存的一种物理划分而已。它只局限在内存，而且只局限在JVM的内存。
	*JMM中线程与主内存中同步的八种操作
		1.lock（锁定）：作用于主内存的变量，把一个变量标识变为一条线程独占状态
		2.unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
		3.read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
		4.load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
		5.use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
		6.assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受到的值赋值给工作内存的变量
		7.store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
		8.write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中
	同步规则:
		``如果要把一个变量从主内存中赋值到工作内存，就需要按顺序得执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序得执行store和write操作，但java内存模型只要求上述操作必须按顺序执行，没有保证必须是连续执行
		``不允许read和load、store和write操作之一单独出现
		``不允许一个线程丢弃他的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中
		``不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步到主内存中
		``一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了load和assign操作
		``一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以同时被一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会解锁，lock和unlock必须成对出现
		``如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎中使用这个变量前需要重新执行load或assign操作初始化变量的值
		``如果一个变量事先没有被lock操作锁定，则不允许他执行unlock操作，也不允许去unlock一个被其他线程锁定的变量
		``对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

	并发的优势与风险:
	  优势:
		速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程同时进行。
		设计：程序设计在某些情况下更简单，也可以有更多选择
		资源利用：CPU能够在等待IO的时候做一些其他的事情
	  风险:
	  	安全性：多个线程共享数据时可能会产生于期望不相符的结果
		活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁、饥饿问题
		性能：线程过多时会使得CPU频繁切换，调度时间增多；同步机制；消耗过多内存。

	并发模拟工具:
		PostMan
		Apache Bench(AB):
			ab -n 1000 -c 50 http://localhost:8080/test	 请求1000次,最多允许同时50次访问(并发数为50)
		JMeter
	并发模拟代码:
		Semaphore , CountDownLatch

	原子性:
		AtomicXXX: CAS(compareAndSwap), Unsafe.compareAndSwapInt
		底层实现:
		//var1,传过来的count对象(AtomicInteger)
		//var2,该对象工作内存中的值
		//var4,要增加的值
		public final int getAndAddInt(Object var1, long var2, int var4) {
		//获取底层的该对象的值,主内存中的值
	        int var5;
	        do {
	            var5 = this.getIntVolatile(var1, var2);
	            //不断获取底层的值,直到和当前对象(工作内存中的)值相等(var2=var5).CAS,最终的目的是返回对象最新的值
	        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
	        return var5;
	    }	

	    这里的compareAndSwapInt（var1, var2, var5, var5 + var4）换成 compareAndSwapInt（obj, offset, expect, update）能清楚一些，如果obj内的value和expect相等，就证明没有其他线程改变过这个变量，那么就更新它(主内存)为update,返回的值是var5给工作内存,然后工作内存又+1。

		CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。


		AtomicLong,LongAdder:(面试)
		AtomicLong:死循环方式,如果并发高竞争非常激烈，那么失败量就会很高，性能会受到影响
		LongAdder:jvm对long，double这些64位的变量拆成两个32位的操作,在高并发的场景，通过热点分区来提高并行度,缺点：在统计的时候如果有并发更新，可能会导致结果有些误差,要求数据精确的话不要使用

		compareAndSet:更多用到AtomicBoolean中,保证我们要控制的这段代码只被执行一次.

		AtomicReference:用法同AtomicInteger一样，但是可以放各种对象:AtomicReference<Integer> count = new AtomicReference<>(0);
		AtomicIntegerFieldUpdater:原子性的去更新某一个类的实例的指定的某一个字段.newUpdater()方法的第一个参数是某类的class文件,第二个参数是指定的字段名,注意:该字段必须是volatile修饰,并且不能是static修饰.

		AtomicStampReference:CAS的ABA问题
		ABA问题：在CAS操作的时候，其他线程将变量的值A改成了B由改成了A，本线程使用期望值A与当前变量进行比较的时候，发现A变量没有变，于是CAS就将A值进行了交换操作，这个时候实际上A值已经被其他线程改变过，这与设计思想是不符合的
		解决思路：每次变量更新的时候，把变量的版本号加一，这样只要变量被某一个线程修改过，该变量版本号就会发生递增操作，从而解决了ABA变化	

		AtomicLongArray可以指定更新一个数组指定索引位置的值compareAndSet(int i, long expect, long update)

		AtomicBoolean(平时用的比较多),在并发情况下可以让一段代码只被执行一次.
		AtomicBoolean isHappened =  new AtomicBoolean(false);
		if(isHappened.compareAndSet(false,ture)){
		//在高并发情况下if里面的代码只会被执行一次
			...
		}

	    native:
	    使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。

	    独占锁：是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。

		乐观锁：每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

	原子性-锁-synchronize
	   synchronized：依赖JVM （主要依赖JVM实现锁，因此在这个关键字作用对象的作用范围内，都是同一时刻只能有一个线程进行操作的）
	   Lock：依赖特殊的CPU指令，代码实现，ReentrantLock

	   synchronize
	   修饰代码块:作用范围:大括号括起来的代码,作用于调用的对象.
	   修饰方法:作用范围:整个方法,作用于调用的对象.
	   修饰类:
	   synchronized (SyncronizedExample2.class){
	   ...
	   }
	   作用范围:括号括起来的部分,作用于该类的所有对象
	   修饰静态方法:作用范围:整个静态方法,作用于该类的所有对象

	   作用于调用的对象:多个线程同时执行同一个对象的example01.test()时,是一个先执行完再执行下一个.多个线程同时执行该类的两个对象example01.test(),example02.test(),结果是两个方法交替执行.
	   作用于调用的类:这个类的不同对象多线程执行方法,都是先执行完一个再执行下一个.
	原子性-对比
		synchronize:不可中断锁,适合竞争不激烈,可读性好
		lock:可中断锁,多样化同步,竞争激烈时能维持常态.
		Atomic:竞争激烈时能维持常态,比Lock性能好,但只能同步一个值

		“synchronized不能被继承”: synchronized并不属于方法定义的一部分，不能被继承。子类继承父类,子类覆写了该方法，如果在覆写时不明确写上synchronized，那这个方法就不是synchronized。换句话说，虽然继承了，但是没把synchronized继承下来.

		system.out.println在底层实现时本身会加上synchronized，会影响并发场景下的性能，也让本来的多线程并发变得多了很多阻塞，很多地方甚至变成单线程。因此，强烈建议别使用他

	线程安全性-可见性
		JVM对于可见性，提供了synchronized和volatile
		JMM关于synchronized的两条规定：
		线程解锁前，必须把共享变量的最新值刷新到主内存
		线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁）

		Volatile:通过加入内存屏障和禁止重排序优化来实现
		对volatile 变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存
		对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量
		volatitle的屏障操作都是CPU级别的,但不能保证原子性.其实它比较适合做状态标记量（不会涉及到多线程同时读写的操作）,而且要保证两点： 
		（1）对变量的写操作不依赖于当前值 
		（2）该变量没有包含在具有其他变量的不变的式子中 :
		程序的初始化标识:
		volatile boolean inited = false;
		//线程一：
		context = loadContext();
		inited = true;

		//线程二：
		while（!inited）{
		    sleep();
		}
		doSomethingWithConfig(context);

	线程安全性-有序性
		Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 
		java提供了 volatile、synchronized、Lock可以用来保证有序性 
        另外，java内存模型具备一些先天的有序性，即不需要任何手段就能得到保证的有序性。通常被我们成为happens-before原则（先行发生原则）。如果两个线程的执行顺序无法从happens-before原则推导出来，那么就不能保证它们的有序性，虚拟机就可以对它们进行重排序:

        程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
		锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作
		volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作（重要）
		传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
		线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
		线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
		线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
		对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始


	安全发布对象-发布与逸出
		发布对象:使一个对象能够被当前范围之外的代码所使用。在我们的日常开发中，我们经常要发布一些对象，比如通过类的非私有方法返回对象的引用，或者通过公有静态变量发布对象。
	    对象逸出:一种错误的发布。当一个对象还没有构造完成时，就使它被其他线程所见。
	    不安全发布对象的两种代码演示:

	    如何安全发布对象？共有四种方法
	    1、在静态初始化函数中初始化一个对象引用
	    2、将对象的引用保存到volatile类型域或者AtomicReference对象中
	    3、将对象的引用保存到某个正确构造对象的final类型域中
	    4、将对象的引用保存到一个由锁保护的域中
	    我们用各种单例模式来演示其中的几种方法:懒汉式,饿汉式

	    静态块：用static申明，JVM加载类时执行，仅执行一次 
		构造块：类中直接用{}定义，每一次创建对象时执行 
		执行顺序优先级：静态块>main()>构造块>构造方法 
		静态块和静态属性优先执行，谁在前就先执行谁 

		单例: spring管理的bean通常都使用的单例，单例没有专属的使用场景，只要一个类实例化后可以一直使用，就可以设计成单例，减少频繁创建对象的开销

	不可变对象
		有一种对象只要它发布了就是安全的，它就是不可变对象。

		final关键字:
			修饰类：类不能被集成。
			  基础类型的包装类都是final类型的类。final类中的成员变量可以根据需要设置为final，但是要注意的是，final类中的所有成员方法都会被隐式的指定为final方法
			修饰方法：
			  (1)被继承后不能修改该方法
			  (2)效率：在早期的java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不见效果。一个private方法会被隐式的指定为final方法
			修饰变量：
			  基本数据类型变量，在初始化之后，它的值就不能被修改了。如果是引用类型变量，在它初始化之后便不能再指向另外的对象。(注意:被final修饰的引用类型变量，虽然不能重新指向，但是可以修改)

		创建不可变对象:
			1.Java的Collection类的unmodifiable相关方法,包含:unmodifiableList,unmodifiableMap,unmodifiableSet...
			   使用时: map = Collections.unmodifiableMap(map);

			   unmodifiable相关类的实现原理:
			   	 Collections.unmodifiableMap在执行时,将参数中的map对象进行了转换转换为Collection类中的内部类UnmodifiableMap对象。而UnmodifiableMap对map的更新方法（比如put、remove等）进行了重写，调用时均抛出UnsupportedOperationException异常，这样就做到了map对象的不可变。

			2.使用Guava的Immutable相关类,包含:ImmutableSet,ImmutableList,ImmutableMap...
				1)使用时: Immutablelist<Integer> list = ImmutableList.of(1,2,3);
					list.add(4);  这一句在书写完就会被IDE提示该add方法为过时方法，实际为不可用方法,运行时仍然会抛出UnsupportedOperationException异常.
				Immutable相关类实现原理:跟Java的unmodifiable相关类相似的实现方法.
				2)ImmutableSet除了使用of的方法进行初始化,还可以使用copyof方法,将Collection,iterator类型作为参数.
					private final static ImmutableSet set = ImmutableSet.copyOf(list);
					private final static ImmutableSet set = ImmutableSet.copyOf(list.iterator());
				3)ImmutableMap有特殊的builder写法：
					private final static ImmutableMap<Integer, Integer> map = ImmutableMap.of(1, 2, 3, 4);  //奇数位是key,偶数位是value
 					private final static ImmutableMap<Integer, Integer> map2 = ImmutableMap.<Integer, Integer>builder()
            		.put(1, 2).put(3, 4).put(5, 6).build();			//ImmutableMap的builder写法.

         问: ImmutableXXX修改的集合必须配上final才可以实现不可变对象，否则可以修改其对象引用，是这样吗?
         答: 是的，我们在使用一个不可变对象的实例时，其实很关键一点就是添加final修饰，否则我们很多接口来声明的类实例，在实际使用中被改了引用是一件很尴尬的事情。JDK里许多方法也要求传入接口参数必须是final修饰的变量，保证在方法处理过程中不会修改引用。否则一个参数传到一个方法将很不安全，因为你根本不知道这个方法会对传入的参数做怎样的处理，这也是一个比较好的实践，可以使用final时尽量使用。

    线程封闭:
        它其实就是把对象封装到一个线程里，只有一个线程能看到这个对象，那么这个对象就算不是线程安全的，也不会出现任何线程安全方面的问题。
        比如:
            JDBC的connection连接对象本身不是线程安全的,但是应用连接池,线程从连接池中取connection对象,在线程返回connection之前,连接池不会讲其分配给其他线程,等于将connection封闭到一个线程里面.这样虽然connection对象本身不是线程安全,但是同时连接池的线程封闭也能做到线程安全.
        (1)Ad-hoc 线程封闭：
        (2)堆栈封闭:
            堆栈封闭其实就是方法中定义局部变量。不存在并发问题。多个线程访问一个方法的时候，方法中的局部变量都会被拷贝一份到线程的栈中（Java内存模型），所以局部变量是不会被多个线程所共享的。
        (3)ThreadLocal 线程封闭: 特别好的线程封闭方法
            每个线程都会维护一个map,map的key是每个线程的名称而map的value就是我们要封闭的对象.多个线程互不干扰.

        ``创建一个包含ThreadLocal对象的类ThreadLocalCache，并提供基础的添加、删除、获取操作
        ``创建一个Filter,在Filter中对ThreadLocal做添加操作
        ``创建拦截器interceptor,重写preHandle()(它是进入url之前拦截处理)和afterCompletion()(它是执行完url之后拦截处理)方法,在afterCompletion方法中ThreadLocalCache.remove()释放,避免内存泄漏.
        ``在springboot的启动类Application中@Bean注册filter与interceptor.(也可以写一个配置类来@Bean注册)
        ``写一个Controller来模拟请求.
          先进filter,后进interceptor

        问:为什么要使用过滤器add和拦截器remove,用其中的一个就可以实现把
        答:首先如果项目里只有一个filter和一个interceptor，或者只有其中一种时，用其中一个就可以实现，这是没问题的。
           接下来，说一下这样做的目的。这样做，主要是考虑在项目中有多个filter和一个interceptor时，比如项目里同时有登录校验的filter、权限校验的filter，然后有一个interceptor做一些通用的记录（比如接口耗时）。这时，在登录校验的filter里把登录校验的信息写入threadLocal，然后需要在接口该执行的都执行完再从threadlocal中移除登录信息。在多个filter时，直接使用一个就很可能出现后面的filter还要使用，但是还没使用时就已经移除的情况。这时放到interceptor里保证最后阶段移除就明显更不容易出错了。

    常用的线程不安全的类:
    		(1)StringBuilder与StringBuffer
    			StringBuilder是线程不安全的，而StringBuffer是线程安全的。分析源码：StringBuffer的方法使用了synchronized关键字修饰。
    			StringBuilder效率高,可以在方法里做局部变量时使用,线程封闭.
    		(2)simpleDateFormat与jodatime插件
    			simpleDateFormat是线程不安全的,可以在new对象的时候将其放在方法里面,因为局部变量线程封闭,这样就是线程安全的.
    			jodatime插件可保证线程安全性.
    			Joda 类具有不可变性，因此它们的实例无法被修改。（不可变类的一个优点就是它们是线程安全的）
    			private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("yyyyMMdd");
    			private static void update(int i) {
    			    log.info("{}, {}", i, DateTime.parse("20180208", dateTimeFormatter).toDate());
    			}
    		(3)ArrayList,HashSet,HashMap等Collection类
    			线程不安全的原因,以arrayList为例,每次进行插入操作的时候,都会做扩容处理,会导致线程不安全.因为添加一个元素时会分两步来完成:
    				1.增大数组的size值
    				2.在数组Item[size]的位置存放此元素
    			由于这两步不是原子性的,所以多线程时会出现线程安全问题.
    		(4)先检查再执行: if(condition(a)){handle(a)};
    		   判断语句和执行语句无法保证原子性,所以线程不安全

    		问: 以下业务代码:
    		 for (Long houseId: houseIds) {
    		    //线程处理
    		    executorService.execute(() -> {
    		        //一些查询操作
    		        xxxService.select();
    		        //一些更新缓存的操作
    		        xxxRedis.update();
    		        if(如果不需要保存){
    				    //停止线程
    			        Thread.currentThread().interrup();
    		        }
    		        //一些添加操作
    		        xxxService.batchInsert();
    		    }
    		 }
    		 程序却会不断抛出InterruptedException,线程不是在wait, join, sleep时候被interrupt才会抛出这个异常吗?
    		答: 实际中很少有直接调用interrupt的，你如果想结束线程，直接return就可以了啊，你目前使用的是线程池，你很难知道其他线程是什么状态，完全交给线程池调度就可以了。

    		问: StringBuilder快，StringBuffer安全，那String这个类，顿时就有点尴尬了，那我们一般为什么不就用这两个类，干嘛还用String？（尽管我们知道，很多场景下，我们一般都是习惯性定义字符串为String）
    		这三者的应用场景有什么区别，什么情况下，我该用哪个类，尤其String类。
    		答: 字符串拼接的时候，用SringBuilder和StringBuffer性能更好，因为String是不能改变的，例如我们声明了一个String s = "abc";当我们改为String s = s+"de";的时候，其实是重新声明了一个String s，就是String s="abc"+"de";而不是直接在之前的String上面操作，所以会有性能上面的问题。而StringBuilder和StringBuffer调用append方法是直接在上面进行修改操作的，性能比String好。然后其余的问题就是StringBuilder是线程不安全的，而StringBuffer是线程安全的，在不同的场景进行选择了。 补充一点，如果String 后面是多个【常量】字符串拼接，其实和SringBuilder、StringBuffer也差不多，这时候编译器在编译阶段会做特殊的优化


    	同步容器:
    		(1)ArrayList的线程安全类: Vector和Stack
    		   Vector相当于加了synchronized的arrayList;
    		   Stack(栈)它继承了Vector,也是使用synchronized修饰了.
    		  但是同步容器在某些情况下是线程不安全的:
    		  比如并发执行删除与获取的操作.有可能上面刚删除完,下面就获取,就会报数组越界异常.因为synchronize只锁了方法,要想两个方法之间保证原子性就需要加上Lock或者synchronized来同步.
    		(2)HashMap的线程安全类: HashTable , 使用了synchronized修饰
            (3)Collections类中的相关同步方法:
                Collections.synchronizedList(List<T>);
                Collections.synchronizeMap(Map<K,T>);
                Collections.synchronizeSet(Set<T>);
                ...等等
             使用: private static List<Integer> list = Collections.synchronizedList(Lists.newArrayList());

             另外:使用foreach\iterator遍历集合的时候不能进行增删操作,会报错ConcurrentModificationException,使用for循环是ok的.
             解决办法:1.在循环里将循坏的对象标记,然后出循环时处理
                     2.在并发环境在可以通过加锁,或者使用并发容器来解决

         并发容器J.U.C:
                    TreeSet:它可以给Set集合中的元素进行指定方式(1自身具备比较性 2自定义比较器)的排序。
                    OOM - Out of Memory，内存溢出
                    J.U.C是Java.util.concurrency缩写
                    上面我们介绍了ArrayList、HashMap、HashSet对应的同步容器保证其线程安全，这节我们介绍一下其对应的并发容器。
                    (1) ArrayList -> CopyOnWriteArrayList
                        CopyOnWriteArrayList写操作时复制，当有新元素添加到集合中时，从原有的数组中拷贝一份出来，然后在新的数组上作写操作，将原来的数组指向新的数组。整个数组的add操作都是在锁的保护下进行的，防止并发时复制多份副本。读操作是在原数组中进行，不需要加锁
                        缺点：
                        1.写操作时复制消耗内存，如果元素比较多时候，容易导致young gc 和full gc。
                        2.不能用于实时读的场景.由于复制和add操作等需要时间，故读取时可能读到旧值。
                        能做到最终一致性，但无法满足实时性的要求，更适合读多写少的场景。
                        优点:
                        如果无法知道数组有多大，或者add,set操作有多少，慎用此类,在大量的复制副本的过程中很容易出错。
                        设计思想：
                        1.读写分离
                        2.最终一致性
                        3.使用时另外开辟空间，防止并发冲突
                    (2) HashSet -> CopyOnWriteArraySet
                        它是线程安全的，底层实现使用的是CopyOnWriteArrayList，因此它也适用于大小很小的set集合，只读操作远大于可变操作。因为他需要copy整个数组，所以包括add、remove、set它的开销相对于大一些。
                    (3) TreeSet -> ConcurrentSkipListSet




            问: 我看《Java并发编程实战》，里面介绍ReentrantReadWriteLock,读锁和写锁，里面说读锁类似于Semaphore而不是锁，只是维护当前活跃的读线程的数量，我知道读锁是共享锁而写锁是排它锁，那我的理解是共享锁不是一种真正的锁，那他又有什么意义呢？
            答: 你好，他存在的意义可以参考ReentrantLock，ReentrantLock实现了标准的互斥操作，也就是一次只能有一个线程持有锁，显然这个特点在一定程度上面减低了吞吐量。
            实际应用场景中我们会经常遇到这样的情况：某些资源需要并发访问，并且大部分时间是用来进行读操作的，写操作比较少，而锁是有一定的开销的，当并发比较大的时候，锁的开销就非常可观了。所以如果可能的话就尽量少用锁，如果非要用锁的话就尝试看能否能实现读写分离，将其改造为读写锁。
            ReentrantReadWriteLock主要就是为了解决这种场景，尽可能的减少排他锁的使用，同时也能保证足够的线程安全。
            问: 既然读操作很多，加排他锁的开销又大，那我直接对读操作不加任何锁不是更好吗，为啥还需要读锁
            答: 还记得课程开始部分讲线程安全时的例子不，不加锁时其他线程做了修改后，你当前的线程可能读取不到最新值，导致操作出现线程安全问题

            问: 老师，您好！volitile 修饰一个map 当map很大的时候会不会导致OOM？
            答: 你好，volatile本质上不会额外消耗内存，只是强制代码读取主存里最新的值。如果因为map过大导致oom，那本质上是map的问题，而不是因为有volatile修饰。
            问: 老师，主存是什么？我一直对这个词很模糊，是JVM里的堆，栈？
            答: 主存是公共空间，基本可以类比为虚拟机模型中的堆,对象创建好了都是在主存里，所有线程都可以访问。 工作内存是线程的私有内存，只有本线程可以访问，如果线程要操作主存中的某个对象，必须从主存中拷贝到工作内存，在对工作内存中的副本进行操作，操作后再写入主存，而不能对主存的对象直接操作。 volatile主要是在某些场合需要强制读取主存里的数据。

            问: 老师，copyonwriteArrayList的读没有加锁，为什么还是线程安全的呢？
                public E get(int index) {
                   return get(getArray(), index);
                }
               当一个线程copyonwriteArrayList调用add(int index, E element)时，另一个线程读的时候是原来的数组数据，不是脏读了吗？
            答: 你好,CopyOnWriteArrayList不适用于实时读的场景，像拷贝数组、新增元素都需要时间,所以调用一个set操作后,读取到数据可能还是旧的,虽然CopyOnWriteArrayList能做到最终一致性,但是还是没法满足实时性要求。因此如果对实时要求特别高，那么CopyOnWriteArrayList 可能确实不太适合，他主要用于读多写少的情景，这代表实际的写理论上会非常少，而且是通过最终数据的正确来保证线程安全。
            如果任何一个时间点都期望数据是正确的，那么这时候应该考虑使用同步容器，并发容器没法取代同步容器，并发容器更多的是在保证线程安全的大前提下，尽可能提升并发的性能
